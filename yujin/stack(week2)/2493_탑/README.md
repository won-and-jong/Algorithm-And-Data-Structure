
입력받은 탑의 높이를 스택에 저장하고 하나씩 뽑아서 현재 스택의 top과 비교한다. 즉, 맨 뒤에서부터 탑을 확인하고 수신탑을 결정한다.
T스택의 top이 더 클 때까지 tmp스택에 탑의 높이를 저장하고
tmp에 저장된 탑의 개수에 +1을 하여 해당 탑 번호를 result배열에 저장하여 출력해주었다.
그리고 다음 탑을 확인할 때에는 tmp에 저장된 탑의 정보를 다시 T에 담아주었다.
그런데 시간 초과로 틀렸다.
n개의 원소가 있는 경우, 최악의 경우에 루프를 한번 실행하는 데에 2n시간이 걸린다.
즉, 해당 코드는 `O(n^2)` 시간이 걸린다. 스택을 사용했을뿐이지 그리디로 푼 것과 다름이 없는 방법이었다.

```cpp
#include <bits/stdc++.h>
using namespace std;

stack<int> T;
stack<int> tmp;
int result[500001];

int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		int h;
		cin >> h;
		T.push(h);
	}
	for (int i = n; i > 0; i--) {
		int now = T.top(); T.pop();
		while (!T.empty() && now > T.top()) {
			tmp.push(T.top()); T.pop();
		}
		result[i] = i - (tmp.size() + 1);
		while (!tmp.empty()) {
			T.push(tmp.top());
			tmp.pop();
		}
	}
	for (int i = 1; i <= n; i++)
		cout << result[i] << " ";
	cout << "\n";
}
```

시간초과가 발생하는 이유는 알겠는데, 해결은 못하겠어서 예전에 풀었던 코드를 참고하였다.
뒤에서부터 확인하는 것이 아니라 **앞에서부터 탑을 확인**하여 수신탑을 결정한다.
현재 확인하는 탑의 높이보다 낮은 높이의 탑이라면 스택에 저장할 필요가 없으므로 k번째 탑의 수신탑을 확인하는데에 최대 k-1시간만 걸린다. k-1 시간조차도 안 걸린다 (거의 한 두번의 비교연산으로 결정 가능하다)
&nbsp;예시로 확인을 해보면 6 9 5 7 4에서 높이가 7인 4번째 탑의 수신탑을 확인하는 경우
&nbsp;스택에는 9 5 탑의 번호인 2 3 이 들어있을 것이다
&nbsp;스택의 맨 윗값인 3번 탑의 **높이 5**와 현재 확인하려는 **높이의 7**을 비교하면 7이 더 크고 **스택에서 5를 제거**하면 된다.
&nbsp;해당 값을 저장해둘 필요도 없다. 왜냐하면 다음 탑인 4의 수신탑을 확인할 때에도 7탑에 가로막히면 5탑에는 어차피 수신되지 않기 때문이다.
k번째 탑의 수신탑을 확인하는데에 최대 k-1시간씩 걸리면 n(n+1)/2 로 O(n^2) 시간인 것 아닌가 라고 생각했다
1 2 3 4 5 가 최악의 경우인가도 생각했는데 아니다! 1 6 2 7 3 8 이런식으로 작은수와 큰수가 번갈아 나오는 경우가 최악의 경우인 듯하다. k/2 시간 정도인 것으로 추측된다.
근데 k번째 탑에서 k/2시간만큼 걸린다고 해도 n(n+1)/2 로 O(n^2) 시간인 것 아닌가..?
더 알아보고 알게되면 추가해보도록 해야겠다.
인터넷에서는 해당 코드는 `O(n)`시간 내에 동작이 가능하다고 한다